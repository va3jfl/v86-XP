<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>V86 Windows XP Mini</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            background-color: #1a1a1a;
            color: #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #screen_container {
            background-color: #000;
            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            line-height: 0; 
            margin-bottom: 10px;
        }
        #screen_container canvas {
            display: block; 
        }
        #toolbar {
            width: 800px;
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .btn {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 15px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            border-radius: 4px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .btn:hover {
            background-color: #444;
        }
        .btn:active {
            background-color: #222;
        }
        /* Hide the ugly default file inputs */
        #restore_file, #cdrom_file {
            display: none;
        }
        #status_bar {
            margin-top: 15px;
            width: 800px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        #progress {
            background-color: #4CAF50;
            height: 20px;
            width: 0%;
            transition: width 0.1s linear; 
        }
        #status_text {
            margin-top: 5px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

    <h2>V86 Windows XP Mini (24 MB)</h2>

    <div id="toolbar">
        <button id="btn_save" class="btn">üíæ Save State</button>
        <button id="btn_load" class="btn" onclick="document.getElementById('restore_file').click()">üìÇ Load State</button>
        
        <div style="flex-grow: 1;"></div>

        <button id="btn_mount" class="btn" onclick="document.getElementById('cdrom_file').click()">üíø Mount ISO</button>
        <button id="btn_eject" class="btn">‚èèÔ∏è Eject ISO</button>

        <input type="file" id="restore_file">
        <input type="file" id="cdrom_file" accept=".iso,.img,.bin">
    </div>

    <div id="screen_container">
        <div style="white-space: pre; font: 14px monospace; line-height: 14px"></div>
        <canvas style="display: none"></canvas>
    </div>

    <div id="status_bar"><div id="progress"></div></div>
    <div id="status_text">Initializing environment...</div>

    <script src="build/libv86.js"></script>

    <script>
        "use strict";

        // === GENERIC COMPRESSED LOADER (Works for ISOs or States) ===
        async function loadCompressedFile(url, progressBar, statusText) {
            const cacheName = 'v86-xp-live-assets-v1'; // Cache name for ISOs
            
            const supportsCache = 'caches' in window;
            const supportsDecompression = 'DecompressionStream' in window;

            // 1. Check Cache
            if (supportsCache) {
                try {
                    const cache = await window.caches.open(cacheName);
                    // Map .gz URL to uncompressed cache key
                    const cacheKey = url.replace('.gz', ''); 
                    const cachedResponse = await cache.match(cacheKey);

                    if (cachedResponse) {
                        console.log(`Loading ${url} from cache...`);
                        statusText.innerText = "Loading ISO from local cache (Instant)...";
                        progressBar.style.width = "100%";
                        return await cachedResponse.arrayBuffer();
                    }
                } catch (e) {
                    console.warn("Cache access failed (HTTP/Private Mode).");
                }
            }

            // 2. Download
            console.log(`Downloading ${url}...`);
            statusText.innerText = `Downloading compressed ISO...`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to fetch ${url}`);

                const contentLength = response.headers.get('content-length');
                const total = parseInt(contentLength, 10);
                let loaded = 0;

                const reader = response.body.getReader();
                const chunks = [];

                while(true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    loaded += value.length;
                    
                    if (total) {
                        const percent = Math.round((loaded / total) * 100);
                        progressBar.style.width = percent + "%";
                        statusText.innerText = `Downloading ISO (GZIP): ${percent}%`;
                    } else {
                        const mb = (loaded / (1024 * 1024)).toFixed(1);
                        statusText.innerText = `Downloading ISO (GZIP): ${mb} MB...`;
                    }
                }

                const compressedBlob = new Blob(chunks);

                // 3. Decompress
                statusText.innerText = "Decompressing ISO...";
                let uncompressedBuffer;

                if (supportsDecompression) {
                    const ds = new DecompressionStream('gzip');
                    const stream = compressedBlob.stream().pipeThrough(ds);
                    const decompressedResponse = new Response(stream);
                    uncompressedBuffer = await decompressedResponse.arrayBuffer();
                } else {
                    throw new Error("Browser does not support native GZIP decompression.");
                }

                // 4. Save to Cache
                if (supportsCache) {
                    try {
                        const cache = await window.caches.open(cacheName);
                        const cacheKey = url.replace('.gz', '');
                        const headers = new Headers({ 'Content-Length': uncompressedBuffer.byteLength });
                        await cache.put(cacheKey, new Response(uncompressedBuffer, { headers }));
                        console.log("Uncompressed ISO saved to cache.");
                    } catch (e) {
                        console.warn("Cache write failed (Quota?):", e);
                    }
                }

                return uncompressedBuffer;

            } catch (err) {
                statusText.innerText = "Error loading: " + err.message;
                progressBar.style.backgroundColor = "#ff5555";
                throw err;
            }
        }

        window.onload = async function() {
            const statusText = document.getElementById("status_text");
            const progressBar = document.getElementById("progress");

            // === LIVE ISO CONFIGURATION ===
            const PRESETS = {
                memory: 512 * 1024 * 1024,      
                vga_memory: 32 * 1024 * 1024,    
                bios_path: "bios/seabios.bin",
                vga_bios_path: "bios/vgabios.bin",
                wasm_path: "build/v86.wasm",
                
                // Pointing to the GZ file now:
                cdrom_url: "VirtualXP.iso.gz"  
            };

            // --- STEP 1: LOAD & DECOMPRESS ISO ---
            let isoBuffer;
            try {
                // We reuse the generic loader for the ISO
                isoBuffer = await loadCompressedFile(PRESETS.cdrom_url, progressBar, statusText);
            } catch (e) {
                console.error(e);
                return; 
            }

            // --- STEP 2: START EMULATOR ---
            statusText.innerText = "Launching V86 Emulator...";

            var emulator = new V86({
                wasm_path: PRESETS.wasm_path,
                memory_size: PRESETS.memory,
                vga_memory_size: PRESETS.vga_memory,
                screen_container: document.getElementById("screen_container"),
                
                bios: { url: PRESETS.bios_path },
                vga_bios: { url: PRESETS.vga_bios_path },
                
                // Pass the decompressed buffer to CDROM
                cdrom: { buffer: isoBuffer },
                
                // Boot from CD-ROM (Order: CD, HDD, Floppy)
                boot_order: 0x213, 
                
                autostart: true,
                network_relay_url: null, 
            });

            // --- MOUSE LOCK ---
            document.getElementById("screen_container").addEventListener("mousedown", function() {
                emulator.lock_mouse();
            });

            // --- SAVE STATE ---
            document.getElementById("btn_save").onclick = async function() {
                statusText.innerText = "Generating state file...";
                progressBar.style.width = "100%";
                progressBar.style.backgroundColor = "#ff9800"; 

                await new Promise(r => setTimeout(r, 50));

                try {
                    const new_state = await emulator.save_state();
                    const blob = new Blob([new_state], { type: "application/octet-stream" });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = "v86-live-xp-state.bin";
                    a.click();
                    window.URL.revokeObjectURL(url);
                    
                    statusText.innerText = "State saved successfully.";
                    progressBar.style.width = "0%";
                    progressBar.style.backgroundColor = "#4CAF50"; 
                    emulator.lock_mouse();
                } catch(e) {
                    console.error(e);
                    statusText.innerText = "Error saving state.";
                }
            };

            // --- LOAD STATE ---
            document.getElementById("restore_file").onchange = function() {
                const file = this.files[0];
                if (!file) return;

                const filereader = new FileReader();
                filereader.onprogress = function(e) {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        progressBar.style.width = percent + "%";
                        statusText.innerText = `Reading save file: ${percent}%`;
                    }
                };

                filereader.onload = async function(e) {
                    const buffer = e.target.result;
                    statusText.innerText = "Restoring emulator state...";
                    try {
                        await emulator.restore_state(buffer);
                        statusText.innerText = "State restored successfully!";
                        progressBar.style.width = "0%"; 
                        emulator.lock_mouse(); 
                    } catch(err) {
                        statusText.innerText = "Error restoring state: " + err;
                        console.error(err);
                        progressBar.style.backgroundColor = "#ff5555";
                    }
                };
                filereader.readAsArrayBuffer(file);
                this.value = ""; 
            };

            // --- CD-ROM MOUNT ---
            document.getElementById("cdrom_file").onchange = function() {
                const file = this.files[0];
                if (!file) return;

                statusText.innerText = "Reading ISO file...";
                const filereader = new FileReader();
                
                filereader.onprogress = function(e) {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        progressBar.style.width = percent + "%";
                        statusText.innerText = `Loading ISO: ${percent}%`;
                    }
                };

                filereader.onload = async function(e) {
                    statusText.innerText = "Mounting ISO...";
                    try {
                        const buffer = new Uint8Array(e.target.result);
                        await emulator.set_cdrom(buffer);
                        statusText.innerText = `ISO Mounted: ${file.name}`;
                        progressBar.style.width = "0%";
                    } catch(err) {
                        statusText.innerText = "Error mounting ISO: " + err;
                        console.error("Mount error:", err);
                    }
                };

                filereader.readAsArrayBuffer(file);
                this.value = ""; 
                emulator.lock_mouse();
            };

            // --- CD-ROM EJECT ---
            document.getElementById("btn_eject").onclick = function() {
                try {
                    emulator.eject_cdrom();
                    statusText.innerText = "CD-ROM Ejected.";
                } catch(e) {
                    statusText.innerText = "Error ejecting ISO.";
                    console.error(e);
                }
                emulator.lock_mouse();
            };

            // --- DOWNLOAD PROGRESS ---
            emulator.add_listener("download-progress", function(e) {
                if (e.lengthComputable || (e.total && e.total > 0)) {
                    const percent = Math.round((e.loaded / e.total) * 100);
                    progressBar.style.width = percent + "%";
                    statusText.innerText = `Downloading ${e.file_name}: ${percent}%`;
                } else {
                    const mb = (e.loaded / (1024 * 1024)).toFixed(1);
                    progressBar.style.width = "100%";
                    progressBar.style.opacity = "0.5"; 
                    statusText.innerText = `Downloading ${e.file_name}: ${mb} MB...`;
                }
            });

            emulator.add_listener("emulator-ready", function() {
                console.log("V86: Core ready. Memory initialized.");
                statusText.innerText = "Core Ready. Booting from ISO...";
            });

            emulator.add_listener("emulator-started", function() {
                progressBar.style.width = "0%";
                statusText.innerText = "System Running: Windows XP Live";
                if (emulator.audio_adapter) emulator.audio_adapter.init(); 
            });

            window.onerror = function(msg, url, line) {
                statusText.innerText = `Error: ${msg}`;
                statusText.style.color = "#ff5555";
                progressBar.style.backgroundColor = "#ff5555";
                console.error(msg);
            };
        };
    </script>
	<h4>Loading and unloading of ISO files is not supported on this basic stripped down system. </h4>
	
	<article>

  <h2>Including Custom Programs in the MiniXP Image</h2>

  <p>
    Due to the stripped-down nature of the MiniXP environment used in this project,
    adding your own programs requires a manual packaging step. This is a limitation
    of keeping the operating system extremely small and self-contained.
  </p>

  <p>
    To include a custom application, you must first extract the compressed ISO image.
    The ISO is distributed in <code>.gz</code> format, so begin by unzipping it using
    a standard gzip-compatible tool.
  </p>

  <p>
    Once extracted, open the ISO using an ISO editing utility such as PowerISO,
    UltraISO, or a similar tool. From there, you can inject your application files
    directly into the filesystem.
  </p>

  <p>
    Optionally, if your application needs to launch automatically on boot, you may
    modify the Windows registry inside the image to configure auto-loading. This step
    is not required for all programs and should be done carefully.
  </p>

  <p>
    After making your changes, save the modified ISO and recompress it using gzip.
    The resulting <code>.iso.gz</code> file can then be referenced by the web-based
    loader HTML used by this project.
  </p>

  <h3>Why This Approach Exists</h3>

  <p>
    This workflow exists because the MiniXP image is intentionally minimal. The goal
    is to achieve an extremely small download size while still providing a functional
    Windows XP live environment.
  </p>

  <p>
    The result is a footprint comparable to archive.org-style DOSBox environments
    that boot lightweight Windows setups ‚Äî except this project runs a Windows XP
    live environment directly in the browser using v86.
  </p>

  <p>
    While traditional DOSBox-based Windows 3.1 setups are often choppy, buggy, and
    slow, this approach achieves similar functionality with better responsiveness,
    at the cost of requiring more effort when packaging custom applications.
  </p>

  <p>
    In practice, this means small applications can be bundled effectively, though
    compatibility is not guaranteed. Some trial and error is expected.
  </p>

  <h3>Recommendation</h3>

  <p>
    This MiniXP configuration should be viewed primarily as an interesting proof
    of concept. If you find the approach compelling and want a more practical setup,
    it is recommended to use the standard v86 Windows XP loader instead.
  </p>

  <p>
    The full loader uses a larger image (approximately 90&nbsp;MB), but in return
    it supports easy mounting of both local and remote ISO files and avoids many
    of the missing core operating system components present in the MiniXP build.
  </p>

  <p>
    For most real-world use cases, the full v86 XP loader provides a smoother and
    more flexible experience.
  </p>

</article>

</body>
</html>